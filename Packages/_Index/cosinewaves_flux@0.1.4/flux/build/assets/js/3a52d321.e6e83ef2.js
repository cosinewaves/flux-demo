"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[202],{7530:e=>{e.exports=JSON.parse('{"functions":[{"name":"addState","desc":"You can add a state to the state machine, which can then be entered and exited with optional lifecycle events.\\n\\n\\t","params":[{"name":"state","desc":"","lua_type":"State<S>"}],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","source":{"line":129,"path":"lib/init.luau"}},{"name":"removeState","desc":"Removes a state from the internal registry\\n\\n\\t","params":[{"name":"stateName","desc":"","lua_type":"S"}],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","source":{"line":142,"path":"lib/init.luau"}},{"name":"changeState","desc":"Transitions the Unit from its current state to a new state.\\n\\n**Sequence**:\\n1. Runs all middleware `canTransition` checks.  \\n   - If any returns `false`, the transition is aborted.  \\n2. Calls old state\'s lifecycle hooks (safely wrapped in `pcall`):  \\n   `onBeforeExit \u2192 onExit \u2192 onAfterExit`  \\n3. Updates the Unit\'s `state` field.  \\n4. Calls new state\'s lifecycle hooks (safely wrapped in `pcall`):  \\n   `onBeforeEnter \u2192 onEnter \u2192 onAfterEnter`  \\n5. Notifies all subscribers of the transition.  \\n6. If any lifecycle or subscriber throws, middleware `onError` hooks are invoked.\\n\\n**Note**:  \\n- If the new state is not registered, lifecycle hooks are skipped, \\n  but the `state` value is still updated.  \\n- `onError` middleware provides centralized error handling.  ","params":[{"name":"newState","desc":"The state to transition into","lua_type":"S"},{"name":"eager?","desc":"true = force transition even if old == new, false = lazy (default)","lua_type":"boolean"}],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","source":{"line":172,"path":"lib/init.luau"}},{"name":"subscribe","desc":"Registers a callback to be invoked whenever the Unit changes state.\\n\\n**Sequence**:\\n- After every successful state transition, the callback is called with \\n  `(oldState, newState)`.\\n\\n**Note**: Callbacks should be pure functions without side effects that \\nmodify the Unit directly, to avoid unintended recursion.\\n\\n\\t","params":[{"name":"callback","desc":"","lua_type":"TransitionCallback<S>"}],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","source":{"line":255,"path":"lib/init.luau"}},{"name":"unsubscribe","desc":"Unregisters a previously subscribed transition callback.\\n\\n**Sequence**:\\n- Removes the first matching callback reference from the subscriber list.\\n- If the callback was not registered, nothing happens.\\n\\n**Note**: The callback reference must be the same function object \\nthat was passed to `subscribe`.\\n\\n\\t","params":[{"name":"callback","desc":"function(old: S, new: S) -> ()","lua_type":"TransitionCallback<S>"}],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","source":{"line":275,"path":"lib/init.luau"}},{"name":"getStates","desc":"Returns a list of all registered state names in the Unit.\\n\\n**Note**: The order of states in the returned list is not guaranteed.\\n\\n\\t","params":[],"returns":[{"desc":"array of state names","lua_type":"{ S }"}],"function_type":"method","source":{"line":294,"path":"lib/init.luau"}},{"name":"hasState","desc":"Checks whether a state with the given name is registered in the Unit.\\n\\n\\t","params":[{"name":"stateName","desc":"the state name to check","lua_type":"S"}],"returns":[{"desc":"true if the state is registered, false otherwise","lua_type":"boolean"}],"function_type":"method","source":{"line":310,"path":"lib/init.luau"}},{"name":"reset","desc":"Resets the Unit back to its initial state.\\n\\n**Sequence**:\\n- Calls `changeState(initialState)` internally, \\n  triggering lifecycle hooks and subscriber notifications.\\n\\n\\t","params":[],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","source":{"line":325,"path":"lib/init.luau"}},{"name":"use","desc":"Inserts a table of middleware into the machine. Middleware is different from lifecycles\\nbecause it behaves per-machine, whereas lifecycle events behave per state.\\n\\n\\n\\t","params":[{"name":"middleware","desc":"","lua_type":"Middleware<S>"}],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","source":{"line":340,"path":"lib/init.luau"}}],"properties":[],"types":[{"name":"StateCallback","desc":"A function called during a lifecycle event.\\nCan optionally return another function or nil.","lua_type":"(...any) -> ()?","source":{"line":8,"path":"lib/init.luau"}},{"name":"TransitionCallback<S>","desc":"A function called whenever the Unit transitions between states.\\nReceives the previous state and the new state as parameters.","lua_type":"(oldState: S, newState: S) -> ()","source":{"line":14,"path":"lib/init.luau"}},{"name":"TransitionCheck<S>","desc":"A predicate function called before transitioning between states.\\nIf it returns false, the transition is aborted.","lua_type":"(oldState: S, newState: S) -> boolean","source":{"line":20,"path":"lib/init.luau"}},{"name":"State<S>","desc":"","fields":[{"name":"name","lua_type":"S","desc":"The unique name of the state"},{"name":"onEnter","lua_type":"StateCallback?","desc":"Called when entering the state"},{"name":"onExit","lua_type":"StateCallback?","desc":"Called when exiting the state"},{"name":"onBeforeEnter","lua_type":"StateCallback?","desc":"Called immediately before entering the state"},{"name":"onAfterEnter","lua_type":"StateCallback?","desc":"Called immediately after entering the state"},{"name":"onBeforeExit","lua_type":"StateCallback?","desc":"Called immediately before leaving the state"},{"name":"onAfterExit","lua_type":"StateCallback?","desc":"Called immediately after leaving the state"}],"source":{"line":31,"path":"lib/init.luau"}},{"name":"Middleware<S>","desc":"","fields":[{"name":"beforeChange","lua_type":"TransitionCallback<S>?","desc":"Called before changing any state"},{"name":"afterChange","lua_type":"TransitionCallback<S>?","desc":"Called after changing any state"},{"name":"canTransition","lua_type":"TransitionCallback<S>?","desc":"Predicate function before changing any state"},{"name":"onError","lua_type":"(error: string) -> ()?,","desc":"-- Called whenever a lifecycle hook, subscriber, or middleware throws an error"}],"source":{"line":47,"path":"lib/init.luau"}},{"name":"Unit<S>","desc":"","fields":[{"name":"state","lua_type":"S","desc":"The current state of the Unit"},{"name":"addState","lua_type":"(self: Unit<S>, state: State<S>) -> ()","desc":"Register a new state with optional lifecycle callbacks"},{"name":"removeState","lua_type":"(self: Unit<S>, stateName: S) -> ()","desc":"Unregister a state by its name"},{"name":"changeState","lua_type":"(self: Unit<S>, newState: S, eager: boolean?) -> ()","desc":"Transition to a new state (eager = force transition even if same)"},{"name":"subscribe","lua_type":"(self: Unit<S>, callback: TransitionCallback<S>) -> ()","desc":"Register a callback fired on every state transition"},{"name":"unsubscribe","lua_type":"(self: Unit<S>, callback: TransitionCallback<S>) -> ()","desc":"Remove a previously registered transition callback"},{"name":"getStates","lua_type":"(self: Unit<S>) -> { S }","desc":"Returns all registered state names"},{"name":"hasState","lua_type":"(self: Unit<S>, stateName: S) -> boolean","desc":"Returns true if a given state is registered"},{"name":"reset","lua_type":"(self: Unit<S>) -> ()","desc":"Resets the Unit back to its initial state"},{"name":"use","lua_type":"(self: Unit<S>, middleware: Middleware<S>)","desc":"Middleware functions which act per machine, instead of per state"}],"source":{"line":66,"path":"lib/init.luau"}}],"name":"Unit","desc":"Unit\'s serve as a state machine within Flux. They contain internal tables holding state and subscribers,\\nand also handle functions like subscription callbacks and changing states. ","source":{"line":94,"path":"lib/init.luau"}}')}}]);